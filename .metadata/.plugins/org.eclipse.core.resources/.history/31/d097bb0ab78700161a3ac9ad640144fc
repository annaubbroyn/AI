
import java.util.*;

public class AStar {
	
	//public static int MAX = 1000;
	
	public static Node pop(Node[] array, int size)
	{
		Node out = array[0];
		for(int i = 0; i<size; i++)
		{
			array[i] = array[i+1];
		}
		return out;	
	}
	
	public static void push(Node[] array, Node element, int size)
	{
		array[size] = element;
	}
	
	public static void insert(Node[] array, Node element, int size)
	{
		int i = 0;
		int f = array[i].getF();
		while(f>element.getF() && i<size)
		{
			i++;
			f = array[i].getF();
		}
		for(int j = 0; j<(size-i); j++)
		{
			array[size - j] = array[size - j - 1];
		}
		array[i] = element;
	}
	
	public static boolean isSolution(Node X)
	{
		//Check if solution
		return false; //Return true if solution
	}
	
	public static Node[] generateAllSuccessors(Node X)
	{
		//genAllSuccessors
		int succ_size = 0;
		Node[] SUCC = new Node[succ_size];
		return SUCC;
	}
	
	public static void attachAndEval(Node C, Node P)
	{
		C.parent = P;
		C.setG(P.getG() + arcCost(P,C));
		C.calcH();
		C.updateF();
	}
	
	public static int arcCost(Node P, Node C)
	{
		//Calculate cost
		int cost = 0;
		return cost;
	}
	
	public static void propagatePathImprovements(Node P)
	{
		for(int i = 0; i<P.getNumberOfKids(); i++)
		{
			Node C = P.kids[i];
			if((P.getG() + arcCost(P,C)) < C.getG())
			{
				C.parent = P;
				C.setG(P.getG() + arcCost(P,C));
				C.updateF();
				propagatePathImprovements(C);
			}
		}
	}
	
	public static Node AStar_algorithm()
	{
		Node CLOSED = null;
		Node OPEN = null;
		Node OPEN_last = null;
		Node CLOSED_last = null;
		
		Node n0 = new Node();
		n0.setG(0);
		n0.calcH();
		n0.updateF();
		OPEN = n0;
		OPEN_last = n0;
		
		//Solution solution = new Solution();
		//int closed_size = 0;
		//int open_size = 0;
		while(true)
		{
			if(OPEN == null)
				return null;
			Node X = pop(OPEN);
			//open_size --;
			push(CLOSED, X);
			//closed_size ++;
			if(isSolution(X))
				return X;
			
			Node SUCCnode = generateAllSuccessors(X);
			
			while(SUCCnode != null)
			{
				boolean found_in_OPEN = false;
				boolean found_in_CLOSED = false;
				Node OPENnode = OPEN;
				Node CLOSEDnode = CLOSED;
				while(OPENnode != null)
				{
					if(SUCCnode.isEqualTo(OPENnode))
					{
						SUCCnode = OPENnode;
						found_in_OPEN = true;
						break;
					}
					OPENnode = OPENnode.nextInOPEN;
				}
				if(!found_in_OPEN)
					while(CLOSEDnode != null)
					{
						if(SUCCnode.isEqualTo(CLOSEDnode))
						{
							SUCCnode = CLOSEDnode;
							found_in_CLOSED = true;
							break;
						}
						CLOSEDnode = nextInCLOSED;
					}
				push(X.kids, SUCCnode, X.getNumberOfKids());
				X.setNumberOfKids(X.getNumberOfKids() + 1);
				if(!found_in_OPEN && !found_in_CLOSED)
				{
					attachAndEval(SUCCnode, X);
					insert(OPEN, SUCCnode);
				}
				else if((X.getG() + arcCost(X, SUCCnode)) < SUCCnode.getG())
				{
					attachAndEval(SUCCnode, X);
					if(found_in_CLOSED)
						propagatePathImprovements(SUCCnode);
				}
				SUCCnode = SUCCnode.nextInSUCC;
			}	
		}
	}
	
	public static void main(String[] args)
	{
		
		Node mySolution = AStar_algorithm();
		if(mySolution == null)
			System.out.println("Could not find solution");
		else
		{
			System.out.println("A solution was found: ");
			mySolution.print();
		}

		
	}
	
}
